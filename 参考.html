<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>双人贪吃蛇对战 - 宽屏版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        player1: '#4F46E5',
                        player2: '#EC4899',
                        dark: '#1F2937',
                        light: '#F9FAFB'
                    },
                    fontFamily: {
                        game: ['Poppins', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .grid-bg {
                background-size: 20px 20px;
                background-image: 
                    linear-gradient(to right, rgba(255,255,255,0.05) 1px, transparent 1px),
                    linear-gradient(to bottom, rgba(255,255,255,0.05) 1px, transparent 1px);
            }
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
            .player1-gradient { background: linear-gradient(90deg, #4F46E5, #6366F1); }
            .player2-gradient { background: linear-gradient(90deg, #EC4899, #F472B6); }
            .confetti {
                position: absolute;
                width: 10px;
                height: 10px;
                opacity: 0;
            }
        }
    </style>
</head>
<body class="bg-dark font-game text-light min-h-screen p-0 m-0 overflow-x-hidden">
    <div class="w-full flex flex-col h-screen">
        <header class="py-4 px-6 text-center bg-dark/80 backdrop-blur-sm border-b border-white/10">
            <h1 class="text-[clamp(1.5rem,4vw,2.5rem)] font-bold text-transparent/ bg-clip-text bg-gradient-to-r from-player1 to-player2 text-shadow">双人贪吃蛇对战</h1>
            <p class="text-white/70 mt-1">玩家1: WASD控制 | 玩家2: 方向键控制</p>
        </header>
        
        <!-- 玩家信息和分数 -->
        <div class="flex justify-between px-6 py-3 bg-dark/60 backdrop-blur-sm border-b border-white/10">
            <div class="flex items-center">
                <div class="w-4 h-4 rounded-full bg-player1 mr-2"></div>
                <input type="text" id="player1Name" value="玩家1" 
                    class="bg-dark/50 border border-player1/50 rounded px-3 py-2 text-sm mr-4 focus:outline-none focus:ring-2 focus:ring-player1/70 transition-all w-32">
                <div class="bg-player1/20 px-3 py-1 rounded text-player1 font-bold">
                    分数: <span id="score1" class="ml-1">0</span>
                </div>
            </div>
            
            <div class="flex items-center">
                <div class="bg-player2/20 px-3 py-1 rounded text-player2 font-bold">
                    分数: <span id="score2" class="ml-1">0</span>
                </div>
                <input type="text" id="player2Name" value="玩家2" 
                    class="bg-dark/50 border border-player2/50 rounded px-3 py-2 text-sm ml-4 focus:outline-none focus:ring-2 focus:ring-player2/70 transition-all w-32">
                <div class="w-4 h-4 rounded-full bg-player2 ml-2"></div>
            </div>
        </div>
        
        <!-- 游戏区域 - 横向宽屏设计 -->
        <div class="flex-1 relative overflow-hidden">
            <canvas id="gameCanvas" class="w-full h-full-full grid-bg"></canvas>
            
            <!-- 开始游戏界面 -->
            <div id="startScreen" class="absolute inset-0 bg-dark/90 backdrop-blur-sm flex flex-col items-center justify-center">
                <h2 class="text-3xl font-bold mb-6 text-transparent bg-clip-text bg-gradient-to-r from-player1 to-player2">准备开始!</h2>
                <p class="text-xl mb-8 text-center max-w-md px-4">
                    玩家1: <span class="inline-block px-3 py-1 bg-player1/20 rounded text-player1 mr-4">WASD</span>
                    玩家2: <span class="inline-block px-3 py-1 bg-player2/20 rounded text-player2">方向键</span>
                </p>
                <button id="startButton" class="px-8 py-3 bg-gradient-to-r from-player1 to-player2 rounded-full text-white font-bold shadow-lg hover:shadow-primary/30 hover:scale-105 transition-all duration-300">
                    <i class="fa fa-play mr-2"></i>开始游戏
                </button>
            </div>
            
            <!-- 游戏结束/胜利界面 -->
            <div id="winScreen" class="absolute inset-0 bg-dark/80 backdrop-blur-sm flex flex-col items-center justify-center hidden">
                <h2 class="text-4xl font-bold mb-2 text-transparent bg-clip-text-text bg-gradient-to-r from-yellow-400 to-red-500">恭喜获胜!</h2>
                <p id="winnerName" class="text-3xl font-bold mb-6 text-white"></p>
                <p class="text-xl mb-8">最终比分: <span id="finalScore" class="font-bold"></span></p>
                <button id="restartButton" class="px-8 py-3 bg-gradient-to-r from-player1 to-player2 rounded-full text-white font-bold shadow-lg hover:shadow-primary/30 hover:scale-105 transition-all duration-300">
                    <i class="fa fa-refresh mr-2"></i>再来一局
                </button>
            </div>
        </div>
        
        <footer class="py-2 px-6 text-center text-white/60 text-sm bg-dark/80 backdrop-blur-sm border-t border-white/10">
            <p>吃到食物得分，撞到墙壁、自己或对方身体则失败 | 按空格或Enter也可开始/重新开始游戏</p>
        </footer>
    </div>

    <!-- 音频元素 -->
    <audio id="bgMusic" loop>
        <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3" type="audio/mpeg">
    </audio>
    <audio id="winMusic">
        <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg">
    </audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 获取DOM元素
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const score1Display = document.getElementById('score1');
            const score2Display = document.getElementById('score2');
            const player1NameInput = document.getElementById('player1Name');
            const player2NameInput = document.getElementById('player2Name');
            const startScreen = document.getElementById('startScreen');
            const winScreen = document.getElementById('winScreen');
            const winnerNameDisplay = document.getElementById('winnerName');
            const finalScoreDisplay = document.getElementById('finalScore');
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');
            const bgMusic = document.getElementById('bgMusic');
            const winMusic = document.getElementById('winMusic');
            
            // 游戏变量
            let snake1 = [];
            let snake2 = [];
            let foods = [];
            let direction1 = 'right';
            let direction2 = 'left';
            let nextDirection1 = 'right';
            let nextDirection2 = 'left';
            let score1 = 0;
            let score2 = 0;
            let gameSpeed = 150;
            let gameInterval;
            let isGameActive = false;
            let gridSize;
            let snakeSize;
            let foodSize;
            let foodCount = 5; // 同时存在的食物数量
            
            // 设置Canvas尺寸 - 横向宽屏设计
            function resizeCanvas() {
                // 取窗口宽度的95%作为画布宽度
                const width = window.innerWidth * 0.95;
                // 高度设为宽度的45%，保持横向宽屏比例
                const height = Math.min(width * 0.45, window.innerHeight * 0.65);
                
                canvas.width = width;
                canvas.height = height;
            }
            
            resizeCanvas();
            window.addEventListener('resize', () => {
                resizeCanvas();
                if (isGameActive) {
                    redrawGame();
                }
            });
            
            // 初始化游戏
            function initGame() {
                // 计算网格和元素大小
                gridSize = Math.floor(canvas.width / 60); // 更多列，适应宽屏
                if (gridSize < 8) gridSize = 8; // 最小网格大小
                snakeSize = gridSize * 0.8;
                foodSize = gridSize * 0.7;
                
                // 重置游戏状态
                // 玩家1从左侧开始，向右移动
                snake1 = [
                    {x: 10 * gridSize, y: Math.floor(canvas.height/2/gridSize) * gridSize},
                    {x: 9 * gridSize, y: Math.floor(canvas.height/2/gridSize) * gridSize},
                    {x: 8 * gridSize, y: Math.floor(canvas.height/2/gridSize) * gridSize}
                ];
                direction1 = 'right';
                nextDirection1 = 'right';
                
                // 玩家2从右侧开始，向左移动
                snake2 = [
                    {x: (canvas.width/gridSize - 10) * gridSize, y: Math.floor(canvas.height/2/gridSize) * gridSize},
                    {x: (canvas.width/gridSize - 9) * gridSize, y: Math.floor(canvas.height/2/gridSize) * gridSize},
                    {x: (canvas.width/gridSize - 8) * gridSize, y: Math.floor(canvas.height/2/gridSize) * gridSize}
                ];
                direction2 = 'left';
                nextDirection2 = 'left';
                
                // 重置分数
                score1 = 0;
                score2 = 0;
                score1Display.textContent = score1;
                score2Display.textContent = score2;
                
                // 重置游戏状态
                isGameActive = true;
                gameSpeed = 150;
                foods = [];
                
                // 隐藏界面
                startScreen.classList.add('hidden');
                winScreen.classList.add('hidden');
                stopConfetti();
                
                // 播放背景音乐，暂停胜利音乐
                winMusic.pause();
                winMusic.currentTime = 0;
                bgMusic.volume = 0.3;
                bgMusic.play().catch(e => console.log("背景音乐播放失败:", e));
                
                // 生成食物
                for (let i = 0; i < foodCount; i++) {
                    generateFood();
                }
                
                // 开始游戏循环
                if (gameInterval) clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, gameSpeed);
            }
            
            // 生成食物
            function generateFood() {
                if (foods.length >= foodCount) return;
                
                const maxX = Math.floor(canvas.width / gridSize) - 1;
                const maxY = Math.floor(canvas.height / gridSize) - 1;
                
                // 确保食物不会出现在蛇身上
                let overlapping;
                let newFood;
                
                do {
                    overlapping = false;
                    newFood = {
                        x: Math.floor(Math.random() * maxX) * gridSize,
                        y: Math.floor(Math.random() * maxY) * gridSize,
                        value: Math.random() > 0.7 ? 20 : 10, // 30%概率出现高分食物
                        color: Math.random() > 0.7 ? '#FFD700' : (Math.random() > 0.5 ? '#4ADE80' : '#60A5FA')
                    };
                    
                    // 检查是否与蛇重叠
                    for (let segment of snake1.concat(snake2)) {
                        if (segment.x === newFood.x && segment.y === newFood.y) {
                            overlapping = true;
                            break;
                        }
                    }
                    
                    // 检查是否与其他食物重叠
                    for (let f of foods) {
                        if (f.x === newFood.x && f.y === newFood.y) {
                            overlapping = true;
                            break;
                        }
                    }
                } while (overlapping);
                
                foods.push(newFood);
            }
            
            // 绘制蛇
            function drawSnakes() {
                // 绘制玩家1的蛇
                snake1.forEach((segment, index) => {
                    // 创建渐变色
                    const gradient = ctx.createLinearGradient(
                        segment.x, segment.y, 
                        segment.x + snakeSize, segment.y + snakeSize
                    );
                    gradient.addColorStop(0, '#4F46E5');
                    gradient.addColorStop(1, '#6366F1');
                    
                    // 绘制蛇身体
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.roundRect(
                        segment.x + (gridSize - snakeSize) / 2,
                        segment.y + (gridSize - snakeSize) / 2,
                        snakeSize, snakeSize, snakeSize / 4
                    );
                    ctx.fill();
                    
                    // 绘制眼睛（只在头部）
                    if (index === 0) {
                        drawEyes(segment, direction1, '#fff');
                    }
                });
                
                // 绘制玩家2的蛇
                snake2.forEach((segment, index) => {
                    // 创建渐变色
                    const gradient = ctx.createLinearGradient(
                        segment.x, segment.y, 
                        segment.x + snakeSize, segment.y + snakeSize
                    );
                    gradient.addColorStop(0, '#EC4899');
                    gradient.addColorStop(1, '#F472B6');
                    
                    // 绘制蛇身体
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.roundRect(
                        segment.x + (gridSize - snakeSize) / 2,
                        segment.y + (gridSize - snakeSize) / 2,
                        snakeSize, snakeSize, snakeSize / 4
                    );
                    ctx.fill();
                    
                    // 绘制眼睛（只在头部）
                    if (index === 0) {
                        drawEyes(segment, direction2, '#fff');
                    }
                });
            }
            
            // 绘制眼睛
            function drawEyes(segment, direction, color) {
                ctx.fillStyle = color;
                
                // 根据方向调整眼睛位置
                let leftEyeX, leftEyeY, rightEyeX, rightEyeY;
                const eyeSize = snakeSize / 8;
                
                switch(direction) {
                    case 'right':
                        leftEyeX = segment.x + snakeSize * 0.7;
                        leftEyeY = segment.y + snakeSize * 0.3;
                        rightEyeX = segment.x + snakeSize * 0.7;
                        rightEyeY = segment.y + snakeSize * 0.7;
                        break;
                    case 'left':
                        leftEyeX = segment.x + snakeSize * 0.3;
                        leftEyeY = segment.y + snakeSize * 0.3;
                        rightEyeX = segment.x + snakeSize * 0.3;
                        rightEyeY = segment.y + snakeSize * 0.7;
                        break;
                    case 'up':
                        leftEyeX = segment.x + snakeSize * 0.3;
                        leftEyeY = segment.y + snakeSize * 0.3;
                        rightEyeX = segment.x + snakeSize * 0.7;
                        rightEyeY = segment.y + snakeSize * 0.3;
                        break;
                    case 'down':
                        leftEyeX = segment.x + snakeSize * 0.3;
                        leftEyeY = segment.y + snakeSize * 0.7;
                        rightEyeX = segment.x + snakeSize * 0.7;
                        rightEyeY = segment.y + snakeSize * 0.7;
                        break;
                }
                
                ctx.beginPath();
                ctx.arc(leftEyeX, leftEyeY, eyeSize, 0, Math.PI * 2);
                ctx.arc(rightEyeX, rightEyeY, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                
                // 绘制瞳孔
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(leftEyeX, leftEyeY, eyeSize / 2, 0, Math.PI * 2);
                ctx.arc(rightEyeX, rightEyeY, eyeSize / 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 绘制食物
            function drawFoods() {
                foods.forEach(food => {
                    ctx.save();
                    ctx.translate(food.x + gridSize / 2, food.y + gridSize / 2);
                    ctx.rotate(Date.now() / 2000); // 缓慢旋转
                    
                    // 绘制钻石形状的食物
                    ctx.beginPath();
                    ctx.moveTo(0, -foodSize / 2);
                    ctx.lineTo(foodSize / 2, 0);
                    ctx.lineTo(0, foodSize / 2);
                    ctx.lineTo(-foodSize / 2, 0);
                    ctx.closePath();
                    
                    // 创建径向渐变
                    const gradient = ctx.createRadialGradient(
                        0, 0, 0,
                        0, 0, foodSize / 2
                    );
                    gradient.addColorStop(0, lightenColor(food.color, 30));
                    gradient.addColorStop(1, food.color);
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // 添加边框
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // 绘制分数标记
                    if (food.value > 10) {
                        ctx.fillStyle = '#fff';
                        ctx.font = `${foodSize / 2}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('+', 0, 2);
                    }
                    
                    ctx.restore();
                });
            }
            
            // 颜色调亮辅助函数
            function lightenColor(color, percent) {
                let R = parseInt(color.substring(1, 3), 16);
                let G = parseInt(color.substring(3, 5), 16);
                let B = parseInt(color.substring(5, 7), 16);

                R = Math.floor(R * (100 + percent) / 100);
                G = Math.floor(G * (100 + percent) / 100);
                B = Math.floor(B * (100 + percent) / 100);

                R = (R < 255) ? R : 255;
                G = (G < 255) ? G : 255;
                B = (B < 255) ? B : 255;

                R = Math.round(R);
                G = Math.round(G);
                B = Math.round(B);

                const RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
                const GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
                const BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));

                return `#${RR}${GG}${BB}`;
            }
            
            // 检查碰撞
            function checkCollision(snake, otherSnake) {
                const head = {...snake[0]};
                
                // 检查是否碰到边界
                if (
                    head.x < 0 || 
                    head.x >= canvas.width || 
                    head.y < 0 || 
                    head.y >= canvas.height
                ) {
                    return true;
                }
                
                // 检查是否碰到自己
                for (let i = 1; i < snake.length; i++) {
                    if (head.x === snake[i].x && head.y === snake[i].y) {
                        return true;
                    }
                }
                
                // 检查是否碰到对方蛇身
                for (let segment of otherSnake) {
                    if (head.x === segment.x && head.y === segment.y) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // 检查是否吃到食物
            function checkFoodCollision(head, player) {
                for (let i = 0; i < foods.length; i++) {
                    if (head.x === foods[i].x && head.y === foods[i].y) {
                        const foodValue = foods[i].value;
                        foods.splice(i, 1);
                        generateFood();
                        
                        // 增加对应玩家的分数
                        if (player === 1) {
                            score1 += foodValue;
                            score1Display.textContent = score1;
                        } else {
                            score2 += foodValue;
                            score2Display.textContent = score2;
                        }
                        
                        // 增加游戏速度
                        gameSpeed = Math.max(70, gameSpeed - 1);
                        clearInterval(gameInterval);
                        gameInterval = setInterval(gameLoop, gameSpeed);
                        
                        return true;
                    }
                }
                return false;
            }
            
            // 游戏主循环
            function gameLoop() {
                // 清空画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 更新方向
                direction1 = nextDirection1;
                direction2 = nextDirection2;
                
                // 移动玩家1的蛇
                const head1 = {x: snake1[0].x, y: snake1[0].y};
                switch(direction1) {
                    case 'up':
                        head1.y -= gridSize;
                        break;
                    case 'down':
                        head1.y += gridSize;
                        break;
                    case 'left':
                        head1.x -= gridSize;
                        break;
                    case 'right':
                        head1.x += gridSize;
                        break;
                }
                snake1.unshift(head1);
                
                // 移动玩家2的蛇
                const head2 = {x: snake2[0].x, y: snake2[0].y};
                switch(direction2) {
                    case 'up':
                        head2.y -= gridSize;
                        break;
                    case 'down':
                        head2.y += gridSize;
                        break;
                    case 'left':
                        head2.x -= gridSize;
                        break;
                    case 'right':
                        head2.x += gridSize;
                        break;
                }
                snake2.unshift(head2);
                
                // 检查是否吃到食物
                const ate1 = checkFoodCollision(head1, 1);
                const ate2 = checkFoodCollision(head2, 2);
                
                // 如果没吃到食物，移除尾部
                if (!ate1) snake1.pop();
                if (!ate2) snake2.pop();
                
                // 检查碰撞
                const collision1 = checkCollision(snake1, snake2);
                const collision2 = checkCollision(snake2, snake1);
                
                // 判断游戏结束
                if (collision1 && collision2) {
                    // 两人同时碰撞，平局
                    endGame('平局!', `${score1} - ${score2}`);
                } else if (collision1) {
                    // 玩家1碰撞，玩家2获胜
                    endGame(player2NameInput.value, `${score1} - ${score2}`);
                } else if (collision2) {
                    // 玩家2碰撞，玩家1获胜
                    endGame(player1NameInput.value, `${score1} - ${score2}`);
                }
                
                // 绘制蛇和食物
                drawSnakes();
                drawFoods();
            }
            
            // 重绘游戏（用于窗口大小改变时）
            function redrawGame() {
                // 重新计算网格大小
                const oldGridSize = gridSize;
                gridSize = Math.floor(canvas.width / 60);
                if (gridSize < 8) gridSize = 8;
                
                // 调整蛇的位置以适应新的网格大小
                if (oldGridSize && gridSize) {
                    const scale = gridSize / oldGridSize;
                    
                    snake1 = snake1.map(segment => ({
                        x: Math.round(segment.x * scale / gridSize) * gridSize,
                        y: Math.round(segment.y * scale / gridSize) * gridSize
                    }));
                    
                    snake2 = snake2.map(segment => ({
                        x: Math.round(segment.x * scale / gridSize) * gridSize,
                        y: Math.round(segment.y * scale / gridSize) * gridSize
                    }));
                    
                    foods = foods.map(food => ({
                        ...food,
                        x: Math.round(food.x * scale / gridSize) * gridSize,
                        y: Math.round(food.y * scale / gridSize) * gridSize
                    }));
                }
                
                // 重绘
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawSnakes();
                drawFoods();
            }
            
            // 游戏结束
            function endGame(winnerName, score) {
                isGameActive = false;
                clearInterval(gameInterval);
                
                // 暂停背景音乐
                bgMusic.pause();
                
                // 显示胜利界面
                winnerNameDisplay.textContent = winnerName;
                finalScoreDisplay.textContent = score;
                winScreen.classList.remove('hidden');
                
                // 播放胜利音乐和效果（只播放一次）
                playWinEffects();
            }
            
            // 胜利效果
            function playWinEffects() {
                // 播放胜利音乐（只播放一次）
                winMusic.volume = 0.5;
                winMusic.play().catch(e => console.log("胜利音乐播放失败:", e));
                
                // 创建庆祝彩屑
                createConfetti();
            }
            
            // 创建彩屑效果
            function createConfetti() {
                const container = document.querySelector('#winScreen');
                const colors = ['#4F46E5', '#6366F1', '#EC4899', '#F472B6', '#FFD700', '#4ADE80', '#60A5FA'];
                
                for (let i = 0; i < 200; i++) {
                    const confetti = document.createElement('div');
                    confetti.classList.add('confetti');
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.left = `${Math.random() * 100}%`;
                    confetti.style.top = `-${Math.random() * 20 + 10}px`;
                    confetti.style.width = `${Math.random() * 10 + 5}px`;
                    confetti.style.height = `${Math.random() * 10 + 5}px`;
                    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                    container.appendChild(confetti);
                    
                    // 动画
                    setTimeout(() => {
                        confetti.style.transition = `all ${Math.random() * 3 + 2}s ease`;
                        confetti.style.transform = `translateY(${container.clientHeight + 20}px) rotate(${Math.random() * 360}deg)`;
                        confetti.style.opacity = '1';
                        
                        // 动画结束后移除
                        setTimeout(() => confetti.remove(), 5000);
                    }, 100 * i / 10);
                }
            }
            
            // 停止彩屑效果
            function stopConfetti() {
                const confetti = document.querySelectorAll('.confetti');
                confetti.forEach(c => c.remove());
            }
            
            // 键盘控制
            document.addEventListener('keydown', (e) => {
                if (!isGameActive && e.key !== ' ' && e.key !== 'Enter') return;
                
                // 防止游戏过程中滚动页面
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd', 'W', 'A', 'S', 'D', ' ', 'Enter'].includes(e.key)) {
                    e.preventDefault();
                }
                
                // 开始/重新开始游戏
                if ((e.key === ' ' || e.key === 'Enter') && !isGameActive) {
                    initGame();
                    return;
                }
                
                // 玩家1控制 (WASD)
                switch(e.key.toLowerCase()) {
                    case 'w':
                        if (direction1 !== 'down') {
                            nextDirection1 = 'up';
                        }
                        break;
                    case 's':
                        if (direction1 !== 'up') {
                            nextDirection1 = 'down';
                        }
                        break;
                    case 'a':
                        if (direction1 !== 'right') {
                            nextDirection1 = 'left';
                        }
                        break;
                    case 'd':
                        if (direction1 !== 'left') {
                            nextDirection1 = 'right';
                        }
                        break;
                }
                
                // 玩家2控制 (方向键)
                switch(e.key) {
                    case 'ArrowUp':
                        if (direction2 !== 'down') {
                            nextDirection2 = 'up';
                        }
                        break;
                    case 'ArrowDown':
                        if (direction2 !== 'up') {
                            nextDirection2 = 'down';
                        }
                        break;
                    case 'ArrowLeft':
                        if (direction2 !== 'right') {
                            nextDirection2 = 'left';
                        }
                        break;
                    case 'ArrowRight':
                        if (direction2 !== 'left') {
                            nextDirection2 = 'right';
                        }
                        break;
                }
            });
            
            // 按钮事件
            startButton.addEventListener('click', initGame);
            restartButton.addEventListener('click', initGame);
            
            // 初始化显示开始界面
            startScreen.classList.remove('hidden');
        });
    </script>
</body>
</html>
    